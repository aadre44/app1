{"ast":null,"code":"import getOrCreateMeasurementElement from './getOrCreateMeasurementElement';\nvar MEASUREMENT_ELEMENT_ID = '__visx_splitpath_svg_path_measurement_id';\n\nvar TRUE = function TRUE() {\n  return true;\n};\n\nexport default function getSplitLineSegments(_ref) {\n  var path = _ref.path,\n      pointsInSegments = _ref.pointsInSegments,\n      _ref$segmentation = _ref.segmentation,\n      segmentation = _ref$segmentation === void 0 ? 'x' : _ref$segmentation,\n      _ref$sampleRate = _ref.sampleRate,\n      sampleRate = _ref$sampleRate === void 0 ? 1 : _ref$sampleRate;\n\n  try {\n    var pathElement = getOrCreateMeasurementElement(MEASUREMENT_ELEMENT_ID);\n    pathElement.setAttribute('d', path);\n    var totalLength = pathElement.getTotalLength();\n    var numSegments = pointsInSegments.length;\n    var lineSegments = pointsInSegments.map(function () {\n      return [];\n    });\n\n    if (segmentation === 'x' || segmentation === 'y') {\n      var segmentStarts = pointsInSegments.map(function (points) {\n        var _points$find;\n\n        return (_points$find = points.find(function (p) {\n          return typeof p[segmentation] === 'number';\n        })) == null ? void 0 : _points$find[segmentation];\n      });\n      var first = pathElement.getPointAtLength(0);\n      var last = pathElement.getPointAtLength(totalLength);\n      var isIncreasing = last[segmentation] > first[segmentation];\n      var isBeyondSegmentStart = isIncreasing ? segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY >= start;\n        };\n      }) : segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY <= start;\n        };\n      });\n      var currentSegment = 0;\n\n      for (var distance = 0; distance <= totalLength; distance += sampleRate) {\n        var sample = pathElement.getPointAtLength(distance);\n        var position = sample[segmentation]; // find the current segment to which this sample belongs\n\n        while (currentSegment < numSegments - 1 && isBeyondSegmentStart[currentSegment + 1](position)) {\n          currentSegment += 1;\n        } // add sample to segment\n\n\n        lineSegments[currentSegment].push(sample);\n      }\n    } else {\n      // segmentation === \"length\"\n      var numPointsInSegment = pointsInSegments.map(function (points) {\n        return points.length;\n      });\n      var numPoints = numPointsInSegment.reduce(function (sum, curr) {\n        return sum + curr;\n      }, 0);\n      var lengthBetweenPoints = totalLength / Math.max(1, numPoints - 1);\n\n      var _segmentStarts = numPointsInSegment.slice(0, numSegments - 1);\n\n      _segmentStarts.unshift(0);\n\n      for (var i = 2; i < numSegments; i += 1) {\n        _segmentStarts[i] += _segmentStarts[i - 1];\n      }\n\n      for (var _i = 0; _i < numSegments; _i += 1) {\n        _segmentStarts[_i] *= lengthBetweenPoints;\n      }\n\n      var _currentSegment = 0;\n\n      for (var _distance = 0; _distance <= totalLength; _distance += sampleRate) {\n        var _sample = pathElement.getPointAtLength(_distance); // find the current segment to which this sample belongs\n\n\n        while (_currentSegment < numSegments - 1 && _distance >= _segmentStarts[_currentSegment + 1]) {\n          _currentSegment += 1;\n        } // add sample to segment\n\n\n        lineSegments[_currentSegment].push(_sample);\n      }\n    }\n\n    return lineSegments;\n  } catch (e) {\n    return [];\n  }\n}","map":null,"metadata":{},"sourceType":"module"}